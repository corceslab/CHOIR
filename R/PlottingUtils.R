# ---------------------------------------------------------------------------
# Plotting-related functions
# ---------------------------------------------------------------------------

#' Generate color palette
#'
#' Generate a color palette based on input number. Hex values are standard up to
#' n = 100, but for larger values of n, they are generated using
#' \code{Polychrome::createPalette()}.
#'
#' @param n Number of colors
#'
#' @return Returns a vector of n hex values.
#'
#' @export
#'
CHOIRpalette <- function(n) {
  # ---------------------------------------------------------------------------
  # Check parameter input validity
  # ---------------------------------------------------------------------------
  .validInput(n, "n")
  # ---------------------------------------------------------------------------
  # Create palette
  # ---------------------------------------------------------------------------
  CHOIR_colors <- c("#00CCE3", "#F8A100", "#E81AEF", "#F56900", "#6560FF",
                    "#00D456", "#A25AFF", "#C1D400", "#E58CCC", "#1990FF",
                    "#00DEA3", "#FF5B4B", "#F7D823", "#3BA833", "#AEA9FF",
                    "#FF9C88", "#7DA6CC", "#CB8251", "#61BBFF", "#FF4CF9",
                    "#8B7CFF", "#A99900", "#FCB467", "#FB798C", "#83DD00",
                    "#D98AF7", "#67D4D9", "#08A38E", "#8099FF", "#24B167",
                    "#DBAA00", "#FF3FAD", "#D2C0CA", "#888DB2", "#8D9D63",
                    "#E934FF", "#33C100", "#E0BFA1", "#21ADFD", "#86D582",
                    "#FFA2D9", "#FFB703", "#9DCCC6", "#C078C1", "#F88800",
                    "#9FD362", "#A876EB", "#B4908B", "#FF6C69", "#6693DE",
                    "#E2B0FD", "#AD8EA8", "#93AC00", "#E37847", "#E368FB",
                    "#ECB5D8", "#789F33", "#3AA2AA", "#F3B19C", "#CCC482",
                    "#34DBC9", "#B486E1", "#C39131", "#FF7D4A", "#7F9F87",
                    "#FF9BF3", "#0899D0", "#CCB0DB", "#7DD6B9", "#EABD7F",
                    "#FC76AE", "#D97C9E", "#75C7E4", "#5EA157", "#A5D300",
                    "#FF00FF", "#6A99C5", "#66D100", "#979177", "#E08500",
                    "#EA53C2", "#BAC0FA", "#C3C4AE", "#9785C6", "#6BAE00",
                    "#A78D60", "#EA4974", "#3AEF83", "#D168CC", "#B77E7B",
                    "#77C65D", "#E2D452", "#FFB6C9", "#A2B3CC", "#C660A2",
                    "#616DFF", "#FF9240", "#9B9CA3", "#7DE3FF", "#FF69A3")
  if (n <= 100) {
    values <- CHOIR_colors[1:n]
  } else {
    .requirePackage("Polychrome", source = "cran")
    values <- Polychrome::createPalette(N = n,
                                        seedcolors = CHOIR_colors,
                                        range = c(50, 80))
    names(values) <- NULL
  }
  return(values)
}

#' Run UMAP on CHOIR dimensionality reductions
#'
#' Simplifies running \code{Seurat::RunUMAP()} after CHOIR clustering by
#' automatically fetching the pre-generated dimensionality reductions.
#'
#' @param object An object of class 'Seurat', 'SingleCellExperiment', or
#' 'ArchRProject' that has undergone CHOIR clustering.
#' @param key The name under which CHOIR-related data for this run is retrieved
#' from the object. Defaults to 'CHOIR'.
#' @param reduction A character vector indicating which CHOIR subtree
#' dimensionality reduction to run UMAP on (e.g., 'P0_reduction',
#' 'P1_reduction'). Default = \code{NULL} will run UMAP on all of the
#' dimensionality reductions generated by CHOIR stored under the provided 'key'.
#' @param verbose A boolean value indicating whether to use verbose output
#' during the execution of this function. Can be set to \code{FALSE} for a
#' cleaner output.
#'
#' @return Returns the object with the following added data stored under the
#' provided key: \describe{
#'   \item{reduction}{Cell embeddings for all calculated dimensionality
#'   reductions}
#'   }
#'
#' @export
#'
runCHOIRumap <- function(object,
                         key = "CHOIR",
                         reduction = NULL,
                         verbose = TRUE) {
  # ---------------------------------------------------------------------------
  # Check parameter input validity
  # ---------------------------------------------------------------------------
  .validInput(object, "object", "plotCHOIR")
  .validInput(key, "key", list("plotCHOIR", object))
  .validInput(reduction, "reduction", list("runCHOIRumap", object, key))
  # ---------------------------------------------------------------------------
  # Run UMAPs
  # ---------------------------------------------------------------------------
  # If not provided, extract all CHOIR reductions under provided key
  if (is.null(reduction)) {
    # By object type
    if (methods::is(object, "Seurat")) {
      reduction <- names(object@misc[[key]][["reduction"]])
    } else if (methods::is(object, "SingleCellExperiment")) {
      reduction <- names(object@metadata[[key]][["reduction"]])
    } else if (methods::is(object, "ArchRProject")) {
      reduction <- names(object@projectMetadata[[key]][["reduction"]])
    }
    reduction <- reduction[!grepl("_dist", reduction)]
    reduction <- reduction[!grepl("_UMAP", reduction)]
  }
  # Progress messaging
  if (verbose == TRUE) {
    message("Calculating UMAP embeddings for ",
            length(reduction), " dimensionality reductions..")
    # Progress bar
    pb <- progress::progress_bar$new(format = "Calculating UMAP embeddings.. [:bar] :percent in :elapsedfull",
                                     total = length(reduction), clear = FALSE)
    pb$tick(0)
  }
  for (r in 1:length(reduction)) {
    if (verbose == TRUE) pb$tick()
    # Retrieve reduction
    extracted_reduction <- .retrieveData(object = object,
                                         key = key,
                                         type = "reduction",
                                         name = reduction[r])
    # Run UMAP
    try(CHOIR_UMAP <- suppressMessages(invisible(Seurat::RunUMAP(extracted_reduction))))
    if (exists("CHOIR_UMAP")) {
      # Store embeddings
      object <- .storeData(object, key, "reduction", CHOIR_UMAP@cell.embeddings, paste0(reduction[r], "_UMAP"))
      if (reduction[r] == "P0_reduction") {
        # Store full reduction
        if (methods::is(object, "ArchRProject")) {
          object@reducedDims$CHOIR_P0_reduction_UMAP <- CHOIR_UMAP
        } else {
          object <- .storeData(object = object,
                               key = key,
                               type = "full_reduction",
                               input_data = CHOIR_UMAP@cell.embeddings,
                               name = "CHOIR_P0_reduction_UMAP",
                               reduction_method = "UMAP")
        }
      }
      rm(CHOIR_UMAP)
    } else {
      warning("A UMAP could not be calculated for reduction ", reduction[r], ".")
    }
  }
  # Return object with new UMAP reductions
  return(object)
}

#' Dimensional reduction plot with CHOIR clusters labeled
#'
#' Generate a dimensionality reduction embedding plot colored (by default)
#' according to the clusters identified by CHOIR. Additionally permits plotting
#' mean prediction accuracy scores for pairs of clusters as an overlay.
#'
#' @param object An object of class 'Seurat', 'SingleCellExperiment', or
#' 'ArchRProject' that has undergone CHOIR clustering.
#' @param key The name under which CHOIR-related data for this run is retrieved
#' from the object. Defaults to 'CHOIR'.
#' @param reduction A character vector indicating which CHOIR subtree
#' dimensionality reduction to plot (e.g., 'P0_reduction_UMAP',
#' 'P1_reduction_UMAP'). Default = \code{NULL} will plot the UMAP of the
#' 'P0_reduction_UMAP' generated by CHOIR.
#' @param group_by A character string indicating which metadata column to color
#' cells by. Default = \code{NULL} will color cells according to the clusters
#' identified by CHOIR.
#' @param cells Vector of cell names to plot. Default is all cells.
#' @param highlight_cells Vector of cell names to highlight. Default =
#' \code{NULL}.
#' @param label A boolean value indicating whether to label groups.
#' Defaults to \code{TRUE}.
#' @param legend A boolean value indicating whether to include a legend.
#' Defaults to \code{TRUE}.
#' @param accuracy_scores A boolean value indicating whether to overlay pairwise
#' cluster comparison accuracy scores onto UMAP. Default = \code{TRUE}.
#' @param plot_nearest A boolean value indicating whether to only plot the
#' accuracy score for each cluster's nearest neighboring cluster. Only relevant
#' if \code{accuracy_scores} is \code{TRUE}. Defaults to \code{TRUE}.
#' @param ... Extra parameters passed to \code{Seurat::DimPlot()}.
#'
#' @return A ggplot object.
#'
#' @export
#'
plotCHOIR <- function(object,
                      key = "CHOIR",
                      reduction = NULL,
                      group_by = NULL,
                      cells = NULL,
                      highlight_cells = NULL,
                      label = TRUE,
                      legend = TRUE,
                      accuracy_scores = FALSE,
                      plot_nearest = TRUE,
                      ...) {
  # ---------------------------------------------------------------------------
  # Check parameter input validity
  # ---------------------------------------------------------------------------

  .validInput(object, "object", "plotCHOIR")
  .validInput(key, "key", list("plotCHOIR", object))
  if (is.null(reduction)) {
    reduction <- "P0_reduction_UMAP"
  }
  .validInput(reduction, "reduction", list("plotCHOIR", object, key))
  .validInput(cells, "cells", object)
  .validInput(legend, "legend")
  .validInput(accuracy_scores, "accuracy_scores")

  # ---------------------------------------------------------------------------
  # Prepare object
  # ---------------------------------------------------------------------------
  # Retrieve reduction
  reduction_coords <- .retrieveData(object = object,
                                    key = key,
                                    type = "reduction",
                                    name = reduction)
  # Subset if necessary
  if(is.null(cells)) {
    cells <- rownames(reduction_coords)
  } else {
    if (length(intersect(cells, rownames(reduction_coords))) != length(cells)) {
      warning("Not all selected cells are present in current dimensionality reduction.")
    }
    cells <- intersect(cells, rownames(reduction_coords))
    reduction_coords <- reduction_coords[cells, ]
  }

  # Create temporary Seurat object
  tmp <- matrix(stats::rnorm(nrow(reduction_coords) * 3, 10),
                ncol = nrow(reduction_coords), nrow = 3)
  colnames(tmp) <- rownames(reduction_coords)
  rownames(tmp) <- paste0("t",seq_len(nrow(tmp)))
  tmp_seurat <- Seurat::CreateSeuratObject(tmp, min.cells = 0, min.features = 0, assay = 'tmp')
  # Add dimensionality reduction
  tmp_seurat@reductions$dim_reduction <- suppressWarnings(Seurat::CreateDimReducObject(embeddings = reduction_coords,
                                                                                       key = 'dimreduction',
                                                                                       assay = 'tmp'))
  # Add metadata
  # By object type
  if (methods::is(object, "Seurat")) {
    tmp_seurat@meta.data <- object@meta.data[cells, ]
  } else if (methods::is(object, "SingleCellExperiment")) {
    tmp_seurat@meta.data <- data.frame(object@colData[cells, ])
  } else if (methods::is(object, "ArchRProject")) {
    tmp_seurat@meta.data <- object@cellColData[cells, ]
  }

  # Check if grouping by CHOIR clusters or alt
  if (is.null(group_by)) {
    # Add CHOIR clusters
    alpha <- .retrieveData(object = object,
                           key = key,
                           type = "parameters",
                           name = "pruneTree_parameters")$alpha
    group_by <- paste0("CHOIR_clusters_", alpha)
    color_label <- "CHOIR clusters"
    title <- paste0("CHOIR clusters (\u03b1 = ", alpha, ")")
  } else {
    color_label <- group_by
    title <- group_by
    accuracy_scores <- FALSE
  }
  tmp_seurat@meta.data$groups <- tmp_seurat@meta.data[,group_by]
  group_names <- unique(tmp_seurat@meta.data$groups)
  n_groups <- length(group_names)

  # ---------------------------------------------------------------------------
  # Plot
  # ---------------------------------------------------------------------------

  # With or without highlighting cells
  if (!is.null(highlight_cells)) {
    CHOIR_plot <- Seurat::DimPlot(tmp_seurat,
                                  reduction = "dim_reduction",
                                  group.by = "groups",
                                  label = FALSE,
                                  alpha = 0.1,
                                  ...) +
      ggplot2::scale_color_manual(values = CHOIRpalette(n_groups)) +
      ggplot2::labs(color = color_label) +
      ggplot2::xlab("Dim 1") +
      ggplot2::ylab("Dim 2") +
      ggplot2::ggtitle(title)
    CHOIR_plot <- CHOIR_plot +
      geom_point(data = CHOIR_plot[[1]]$data[highlight_cells,],
                 aes(x = dimreduction_1,
                     y = dimreduction_2,
                     color = groups),
                 alpha = 1)
  } else {
    CHOIR_plot <- Seurat::DimPlot(tmp_seurat,
                                  reduction = "dim_reduction",
                                  group.by = "groups",
                                  label = FALSE,
                                  ...) +
      ggplot2::scale_color_manual(values = CHOIRpalette(n_groups)) +
      ggplot2::labs(color = color_label) +
      ggplot2::xlab("Dim 1") +
      ggplot2::ylab("Dim 2") +
      ggplot2::ggtitle(title)
  }

  # Calculate centroids
  if (label == TRUE) {
    centroid_coords <- tmp_seurat@reductions$dim_reduction@cell.embeddings %>%
      data.frame() %>%
      dplyr::mutate(groups = tmp_seurat@meta.data$groups) %>%
      dplyr::group_by(groups) %>%
      dplyr::summarise(centroid_x = mean(dimreduction_1),
                       centroid_y = mean(dimreduction_2))
  }

  if (n_groups == 1) {
    accuracy_scores <- FALSE
  }

  # Add overlays
  if (accuracy_scores == TRUE) {
    proceed <- TRUE
    # Retrieve accuracy score matrix
    accuracy_matrix <- .retrieveData(object = object,
                                     key = key,
                                     type = "records",
                                     name = paste0("CHOIR_clusters_", alpha, "_accuracies"))
    # Figure out nearest neighboring clusters
    if (plot_nearest == TRUE) {
      distance_matrix <- .retrieveData(object = object,
                                       key = key,
                                       type = "records",
                                       name = paste0("CHOIR_clusters_", alpha, "_distances"))
      try(nearest_cluster <- data.frame(neighbor = apply(distance_matrix, 1,
                                                         FUN = function(x) {
                                                           which(x == min(x, na.rm = TRUE))
                                                         })))
      if (!exists("nearest_cluster")) {
        proceed <- FALSE
      }
    } else {
      nearest_cluster <- data.frame(neighbor = NULL)
    }

    if (proceed == TRUE) {
      # Pair centroids with accuracy scores
      overlay_data <- data.frame(cluster1 = NULL,
                                 cluster2 = NULL,
                                 centroid_x_1 = NULL,
                                 centroid_y_1 = NULL,
                                 centroid_x_2 = NULL,
                                 centroid_y_2 = NULL,
                                 mean_accuracy = NULL)
      for (i in 1:(n_groups-1)) {
        cluster_i <- group_names[i]
        for (j in (i+1):n_groups) {
          cluster_j <- group_names[j]
          if (!is.na(accuracy_matrix[cluster_i, cluster_j])) {
            if (plot_nearest == FALSE) {
              plot_ij <- TRUE
            } else if (plot_nearest == TRUE & nearest_cluster[cluster_i,] == cluster_j) {
              plot_ij <- TRUE
            } else {
              plot_ij <- FALSE
            }
            if (plot_ij == TRUE) {
              overlay_data <- rbind(overlay_data,
                                    data.frame(cluster1 = cluster_i,
                                               cluster2 = cluster_j,
                                               centroid_x_1 = as.numeric(centroid_coords[centroid_coords$groups == cluster_i,
                                                                                         "centroid_x"]),
                                               centroid_y_1 = as.numeric(centroid_coords[centroid_coords$groups == cluster_i,
                                                                                         "centroid_y"]),
                                               centroid_x_2 = as.numeric(centroid_coords[centroid_coords$groups == cluster_j,
                                                                                         "centroid_x"]),
                                               centroid_y_2 = as.numeric(centroid_coords[centroid_coords$groups == cluster_j,
                                                                                         "centroid_y"]),
                                               mean_accuracy = accuracy_matrix[cluster_i, cluster_j]))
            }
          }
        }
      }
      .requirePackage("ggnewscale", source = "cran")
      # Add to plot
      CHOIR_plot <- CHOIR_plot +
        ggnewscale::new_scale_colour() +
        ggplot2::geom_segment(data = overlay_data, ggplot2::aes(x = centroid_x_1,
                                                                y = centroid_y_1,
                                                                xend = centroid_x_2,
                                                                yend = centroid_y_2,
                                                                color = round(100*mean_accuracy, 1)),
                              lineend = "round", linewidth = 2) +
        ggplot2::scale_color_gradientn(colors = c("#FFFC5A","#FFD32B","#FF9965",
                                                  "#FD619D","#C732D5","#6E34FC",
                                                  "#1632FB","#021EA9","#000436"),
                                       breaks = seq(0,100,6)) +
        ggplot2::labs(color = "Mean prediction accuracy")
    }
  }

  # Labels
  if (label == TRUE) {
    CHOIR_plot <- CHOIR_plot +
      ggplot2::geom_text(data = centroid_coords,
                         ggplot2::aes(x = centroid_x,
                                      y = centroid_y,
                                      label = groups),
                         color = "black",
                         size = 2.5)
  }

  # Legend
  if (legend == FALSE) {
    CHOIR_plot <- CHOIR_plot + Seurat::NoLegend()
  }
  return(CHOIR_plot)
}
