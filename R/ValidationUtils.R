# ---------------------------------------------------------------------------
# Validation methods
# ---------------------------------------------------------------------------

# Check parameter input validity ---------------------------
#
# Checks validity of provided values for input parameters
#
# input -- input value
# name -- name of parameter
# other -- other inputs
.validInput <- function(input = NULL,
                        name = NULL,
                        other = NULL) {

  # object
  if (name == "object") {
    # Only allowed to be NULL for function compareClusters()
    # Otherwise, must be either of type Seurat, SingleCellExperiment, or ArchRProject
    if (any(other != "compareClusters", !is.null(input)) &
        length(intersect(methods::is(input), c("Seurat", "SingleCellExperiment", "ArchRProject"))) < 1) {
      stop("Input value for '", name, "' is not one of classes Seurat, SingleCellExperiment, or ArchRProject. Please supply valid input!")
    }
  }

  # key
  if (name == "key") {
    # Must be a character string
    if (!methods::is(input, "character") | length(input) != 1) {
      stop("Input value for '", name, "' is not a single value of class 'character'. Please supply valid input!")
    }
    # If function is buildTree, issue warning if key already exists in object
    # If function is pruneTree, compareClusters, plotCHOIR, or combineTrees issue warning if key does not already exist in object
    if (other[[1]] == "compareClusters" & is.null(other[[2]])) {
      # If function is compareClusters, object can be NULL
    } else if (methods::is(other[[2]], "Seurat")) {
      if (input %in% names(other[[2]]@misc) & other[[1]] == "buildTree") {
        warning("Key '", input, "' already exists in provided object. Existing data may be overwritten.")
      } else if (!(input %in% names(other[[2]]@misc)) & other[[1]] %in% c("pruneTree", "compareClusters", "plotCHOIR", "combineTrees")) {
        warning("Key '", input, "' does not exist in provided object. If you want to use data generated by function buildTree(), make sure the key is the same.")
      }
    } else if (methods::is(other[[2]], "SingleCellExperiment")) {
      if (input %in% names(other[[2]]@metadata) & other[[1]] == "buildTree") {
        warning("Key '", input, "' already exists in provided object. Existing data may be overwritten.")
      } else if (!(input %in% names(other[[2]]@metadata)) & other[[1]] %in% c("pruneTree", "compareClusters", "plotCHOIR", "combineTrees")) {
        warning("Key '", input, "' does not exist in provided object. If you want to use data generated by function buildTree(), make sure the key is the same.")
      }
    } else if (methods::is(other[[2]], "ArchRProject")) {
      if (input %in% names(other[[2]]@projectMetadata) & other[[1]] == "buildTree") {
        warning("Key '", input, "' already exists in provided object. Existing data may be overwritten.")
      } else if (!(input %in% names(other[[2]]@projectMetadata)) & other[[1]] %in% c("pruneTree", "compareClusters", "plotCHOIR", "combineTrees")) {
        warning("Key '", input, "' does not exist in provided object. If you want to use data generated by function buildTree(), make sure the key is the same.")
      }
    }
  }

  # alpha
  if (name == "alpha") {
    # Should be of class 'numeric', must be a single value
    if (!methods::is(input, "numeric") | length(input) != 1) {
      stop("Input value for '", name, "' must be a single value of class 'numeric'. Please supply valid input!")
    }
    # Warn if value is high
    if (input > 0.25) {
      warning("Using a significance threshold ('", name, "') above 0.25 may result in overclustering.")
    }
  }

  # Vector of class character
  # exclude_features, use_features
  if (name %in% c("exclude_features", "use_features")) {
    # If not NULL
    if (!is.null(input)) {
      # Should be of class 'character'
      if (!methods::is(input, "character")) {
        stop("Input value for '", name, "' is not of class 'character'. Please supply valid input!")
      }
    }
  }

  # Single positive integer
  # n_iterations, n_trees, random_seed, n
  if (name %in% c("n_iterations", "n_trees", "random_seed", "n")) {
    # Should be of class 'numeric', must be a single value
    if (!methods::is(input, "numeric") | length(input) != 1) {
      stop("Input value for '", name, "' must be a single value of class 'numeric'. Please supply valid input!")
    }
    # Must be positive integer
    if (input %% 1 != 0 | input < 1) {
      stop("Input value for '", name, "' must be a positive integer. Please supply valid input!")
    }
  }

  # min_accuracy
  if (name == "min_accuracy") {
    # Should be of class 'numeric', must be a single value
    if (!methods::is(input, "numeric") | length(input) != 1) {
      stop("Input value for '", name, "' must be a single value of class 'numeric'. Please supply valid input!")
    }
    # Warn if too low
    if (input < 0.5) {
      warning("Using a '", name, "' value under 0.5 is not recommended, as this is below the accuracy expected by random chance.")
    }
  }

  # Single non-negative integer
  # min_connections, max_repeat_errors
  if (name %in% c("min_connections", "max_repeat_errors")) {
    # Should be of class 'numeric', must be a single value
    if (!methods::is(input, "numeric") | length(input) != 1) {
      stop("Input value for '", name, "' must be a single value of class 'numeric'. Please supply valid input!")
    }
    # Must be a non-negative integer
    if (input %% 1 != 0 | input < 0  ) {
      stop("Input value for '", name, "' must be a non-negative integer. Please supply valid input!")
    }
  }

  # max_clusters
  if (name == "max_clusters") {
    # Must either be "auto" or a positive integer
    if (input != "auto") {
      if (!methods::is(input, "numeric") | length(input) != 1) {
        stop("Input value for '", name, "' must be either 'auto' or a single value of class 'numeric'. Please supply valid input!")
      }
      if (input %% 1 != 0 | input < 1) {
        stop("Input value for '", name, "' must be either 'auto' or a positive integer. Please supply valid input!")
      }
    }
  }

  # normalization_method
  if (name == "normalization_method") {
    # Must be of class 'character'
    if (!methods::is(input, "character")) {
      stop("Input value for '", name, "' is not of class 'character', please supply valid input!")
    }
    # Length must be either 1 or same as n_modalities
    if (length(input) != 1 & length(input) != other[[2]]) {
      stop("Input value(s) for '", name, "' must be either length 1 or the same length as the number of modalities provided provided for 'use_assay' or 'ArchR_matrix'.")
    }
    # Each value must be among the permitted values for the provided object type
    for (i in 1:length(input)) {
      if (methods::is(other[[1]], "ArchRProject") & !(input[i] == "none")) {
        stop("Input value '", input[i], "' for '", name, "' is not among the permitted values for ArchR objects: 'none'. Please supply valid input!")
      } else if (!(methods::is(other[[1]], "ArchRProject")) & !(input[i] %in% c("none", "SCTransform"))) {
        stop("Input value '", input[i], "' for '", name, "' is not among the permitted values for Seurat & SingleCellExperiment objects: 'none' and 'SCTransform'. Please supply valid input!")
      }
      if (methods::is(other[[1]], "Seurat") & input[i] == "SCTransform") {
        if ("Assay5" %in% methods::is(other[[1]][[other[[3]][i]]])) {
          stop("SCTransform is not currently supported for Seurat v5 objects.")
        }
      }
    }
  }

  # subtree_reductions
  if (name == "subtree_reductions") {
    # Must be T/F
    if (!methods::is(input, "logical") | length(input) != 1) {
      stop("Input value for '", name, "' is not a single value of class 'logical', please supply valid input!")
    }
    # If true, warn if max_clusters is "auto" and reduction is supplied
    if (input == TRUE & !is.null(other[[1]]) & other[[2]] == "auto") {
      warning("Supplied dimensionality reduction matrix for parameter '", name, "'",
              " will only be used for the root tree. Thereafter, the dimensionality",
              " reductions for each subtree will be calculated according to the",
              " specified 'reduction_method'. To use only the supplied dimensionality",
              " reduction matrix, set parameter 'subtree_reductions' to FALSE.")
    }
  }

  # reduction_method
  if (name == "reduction_method") {
    # If not NULL
    if (!is.null(input)) {
      # Must be of class character
      if (!methods::is(input, "character")) {
        stop("Input value for '", name, "' is not of class 'character', please supply valid input!")
      }
      # Length must be either 1 or same as n_modalities
      if (length(input) != 1 & length(input) != other[[2]]) {
        stop("Input value(s) for '", name, "' must be either length 1 or same length as the number of modalities provided for 'use_assay' or 'ArchR_matrix'.")
      }
      # Each value must be among the permitted values for the provided object type
      for (i in 1:length(input)) {
        if (methods::is(other[[1]], "ArchRProject") & !(input[i] == "IterativeLSI")) {
          stop("Input value '", input[i], "' for '", name, "' is not among the permitted values for ArchR objects: 'IterativeLSI'. Please supply valid input!")
        } else if (!(methods::is(other[[1]], "ArchRProject")) & !(input[i] %in% c("PCA", "LSI"))) {
          stop("Input value '", input[i], "' for '", name, "' is not among the permitted values for Seurat & SingleCellExperiment objects: 'PCA' and 'LSI'. Please supply valid input!")
        }
      }
    }
  }

  # reduction_params
  if (name == "reduction_params") {
    # Check that it is a list
    if (!methods::is(input, "list")) {
      stop("Input value for '", name, "' is not of class 'list', please supply valid input!")
    }
    # Check whether it is empty
    if (length(input) > 0) {
      # If multiple modalities are used
      if (methods::is(other[[1]], "ArchRProject")) {
        modalities <- other[[2]]
      } else {
        modalities <- other[[3]]
      }
      if (length(modalities) > 1) {
        # Check if names are same as modalities
        if (!identical(names(input), modalities) & length(other[[4]] > 1)) {
          stop("When supplying additional parameters to '", name, "' for use",
               " with multi-modal data requiring different dimensionality reduction approaches,",
               " please provide a list of lists, where each secondary list is named according to",
               " the corresponding assay. See CHOIR vignette on multi-modal data for more details.")
        }
      }
    }
  }

  # n_var_features
  if (name == "n_var_features") {
    # If not NULL
    if (!is.null(input)) {
      # Must be of class 'numeric'
      if (!methods::is(input, "numeric")) {
        stop("Input value for '", name, "' is not of class 'numeric', please supply valid input!")
      }
      # Length must be either 1 or same as n_modalities
      if (length(input) != 1 & length(input) != other) {
        stop("Input value(s) for '", name, "' must be either length 1 or same length as the number of modalities provided for 'use_assay' or 'ArchR_matrix'.")
      }
      for (i in 1:length(input)) {
        # Each value must be a positive integer
        if (input[i] %% 1 != 0 | input[i] < 1) {
          stop("Input value(s) for '", name, "' must be positive integers, please supply valid input!")
        }
        # Warn if < 100
        if (input[i] %% 1 != 0 | input[i] < 1) {
          stop("Input value ", input[i], " for '", name, "' is lower than recommended. Consider increasing this value.")
        }
      }
    }
  }

  # batch_correction_method
  if (name == "batch_correction_method") {
    # Must be of class character
    if (!methods::is(input, "character")) {
      stop("Input value for '", name, "' is not of class 'character', please supply valid input!")
    }
    # Length must be either 1 or same as n_modalities
    if (length(input) != 1 & length(input) != other) {
      stop("Input value(s) for '", name, "' must be either length 1 or same length as the number of modalities provided for 'use_assay' or 'ArchR_matrix'.")
    }
    # Each value must be among the permitted values
    for (i in 1:length(input)){
      if (!(input[i] %in% c("none", "Harmony"))) {
        stop("Input value '", input[i], "' for '", name, "' is not among the permitted values: 'none' and 'Harmony'. Please supply valid input!")
      }
    }
  }

  # batch_correction_params
  if (name == "batch_correction_params") {
    # Check that it is a list
    if (!methods::is(input, "list")) {
      stop("Input value for '", name, "' is not of class 'list', please supply valid input!")
    }
    # Check whether it is empty
    if (length(input) > 0) {
      # Check that batch correction method is "Harmony"
      if (!any(other[[4]] == "Harmony")) {
        warning("Input values for '", name, "' will only be used when 'batch_correction_method' = 'Harmony'.")
      }
      # If multiple modalities are used
      if (methods::is(other[[1]], "ArchRProject")) {
        modalities <- other[[2]]
      } else {
        modalities <- other[[3]]
      }
      if (length(modalities) > 1) {
        # Check if names are same as modalities
        if (!identical(names(input), modalities) & length(other[[4]] > 1)) {
          stop("When supplying additional parameters to '", name, "' for use",
               " with multi-modal data requiring, please provide a list of lists, where each",
               " secondary list is named according to the corresponding assay. See CHOIR",
               " vignette on multi-modal data for more details.")
        }
      }
    }
  }

  # batch_labels, group_by
  if (name %in% c("batch_labels", "group_by")) {
    # If not NULL
    if (!is.null(input)) {
      # Should be of class "character"
      if (!methods::is(input, "character") | length(input) != 1) {
        stop("Input value for '", name, "' must be a single value of class 'character', please supply valid input!")
      }
      # Must be present in metadata of provided object
      if (methods::is(other, "Seurat")) {
        if (!(input %in% colnames(other@meta.data))) {
          stop("Input value for '", name, "' must indicate a column present in the 'meta.data' of the provided object, please supply valid input!")
        }
      } else if (methods::is(other, "SingleCellExperiment")) {
        if (!(input %in% colnames(other@colData))) {
          stop("Input value for '", name, "' must indicate a column present in the 'colData' of the provided object, please supply valid input!")
        }
      } else if (methods::is(other, "ArchRProject")) {
        if (!(input %in% colnames(other@cellColData))) {
          stop("Input value for '", name, "' must indicate a column present in the 'cellColData' of the provided object, please supply valid input!")
        }
      }
    }
  }

  # neighbor_params
  if (name == "neighbor_params") {
    # Check that it is a list
    if (!methods::is(input, "list")) {
      stop("Input value for '", name, "' is not of class 'list', please supply valid input!")
    }
    # Check whether it is empty
    if (length(input) > 0) {
      # If only 1 modality is used or object is of class ArchRProject
      if (methods::is(other[[1]], "ArchRProject") | other[[2]] == 1) {
        if (any(names(input) %in% c("object",
                                    "return.neighbor",
                                    "compute.SNN",
                                    "cache.index",
                                    "do.plot",
                                    "graph.name"))) {
          stop("Parameter inputs for '", name, "' conflict with parameters that are necessarily set by CHOIR. Please supply valid input!")
        }
      } else {
        if (any(names(input) %in% c("object",
                                    "reduction.list",
                                    "dim.list",
                                    "knn.graph.name",
                                    "snn.graph.name",
                                    "weighted.nn.name",
                                    "modality.weight.name",
                                    "return_intermediate"))) {
          stop("Parameter inputs for '", name, "' conflict with parameters that are necessarily set by CHOIR. Please supply valid input!")
        }
      }
    }
  }

  # cluster_params
  if (name == "cluster_params") {
    # Check that it is a list
    if (!methods::is(input, "list")) {
      stop("Input value for '", name, "' is not of class 'list', please supply valid input!")
    }
  }

  # use_assay
  if (name == "use_assay") {
    # If not NULL
    if (!is.null(input)) {
      # Only relevant for Seurat and SingleCellExperiment objects
      if (is.null(other[[1]])) {
        warning("Input value for '", name, "' is not used when 'object' is NULL.")
      } else if (methods::is(other[[1]], "Seurat") | methods::is(other[[1]], "SingleCellExperiment")) {
        # Should be of class 'character'
        if (!methods::is(input, "character")) {
          stop("Input value for '", name, "' is not of class 'character', please supply valid input!")
        }
        # Each value must exist in provided object
        # Dependent on countsplitting for SingleCellExperiment objects
        if (other[[2]] == TRUE &  methods::is(other[[1]], "SingleCellExperiment")) {
          # Default countsplit_suffix values if NULL
          if (is.null(other[[3]])) {
            other[[3]] <- c("_1", "_2")
          }
          input_to_check <- c(paste0(input, other[[3]][1]), paste0(input, other[[3]][2]))
        } else {
          input_to_check <- input
        }
        for (i in 1:length(input_to_check)) {
          if (!(input_to_check[i] %in% names(other[[1]]@assays))) {
            stop("Assay '", input_to_check[i], "' provided for parameter '", name, "' is not present in provided object, please supply valid input!")
          }
          if (grepl("SCT", input_to_check[i])) {
            warning("Input value '", input_to_check[i], "'for '", name, "' suggests that",
                    " SCTransform may have been used to normalize the data. For",
                    " best performance of CHOIR with SCTransform normalization,",
                    " please provide the unnormalized count matrix and set the",
                    " 'normalization_method' parameter to 'SCTransform'.")
          }
        }
      } else if (methods::is(other[[1]], "ArchRProject")) {
        warning("Input value(s) for '", name, "' are not used when provided object is of class 'ArchRProject'.")
      }
    }
  }

  # use_slot
  if (name == "use_slot") {
    # If not NULL
    if (!is.null(input)) {
      # Only relevant for Seurat objects
      if (methods::is(other[[1]], "Seurat")) {
        # Should be of class 'character'
        if (!methods::is(input, "character")) {
          stop("Input value for '", name, "' is not of class 'character', please supply valid input!")
        }
        # Check correspondence with input for 'use_assay'
        if (is.null(other[[2]])) {
          other[[2]] <- Seurat::DefaultAssay(other[[1]])
        }
        # Length must be either 1 or same as n_modalities
        if (length(input) != 1 & length(input) != length(other[[2]])) {
          stop("Input value(s) for '", name, "' must be either length 1 or same length as the number of modalities provided for 'use_assay'.")
        }
        # Slot must be present under specified assay in provided object
        # Dependent on countsplitting
        if (other[[3]] == TRUE) {
          # Default countsplit_suffix values if NULL
          if (is.null(other[[4]])) {
            other[[4]] <- c("_1", "_2")
          }
        } else {
          other[[4]] <- c("", "")
        }
        if (length(other[[2]]) == 1) {
          # Check if object is Seurat v5
          if ("Assay5" %in% methods::is(other[[1]][[other[[2]]]])) {
            if (!(paste0(input, other[[4]][1]) %in% names(other[[1]][[other[[2]]]]@layers))) {
              stop("Layer '", paste0(input, other[[4]][1]), "' is not present in assay '", other[[2]], "' of provided Seurat v5 object, please supply valid input!")
            }
            if (!(paste0(input, other[[4]][2]) %in% names(other[[1]][[other[[2]]]]@layers))) {
              stop("Layer '", paste0(input, other[[4]][2]), "' is not present in assay '", other[[2]], "' of provided Seurat v5 object, please supply valid input!")
            }
          } else {
            try(slot_exists_1 <- methods::validObject(methods::slot(other[[1]][[other[[2]]]], paste0(input, other[[4]][1]))))
            if (!exists("slot_exists_1")) {
              stop("Slot '", paste0(input, other[[4]][1]), "' is not present in assay '", other[[2]], "' of provided Seurat object, please supply valid input!")
            } else if (slot_exists_1 == FALSE) {
              stop("Slot '", paste0(input, other[[4]][1]), "' is not present in assay '", other[[2]], "' of provided Seurat object, please supply valid input!")
            }
            try(slot_exists_2 <- methods::validObject(methods::slot(other[[1]][[other[[2]]]], paste0(input, other[[4]][2]))))
            if (!exists("slot_exists_2")) {
              stop("Slot '", paste0(input, other[[4]][2]), "' is not present in assay '", other[[2]], "' of provided Seurat object, please supply valid input!")
            } else if (slot_exists_2 == FALSE) {
              stop("Slot '", paste0(input, other[[4]][2]), "' is not present in assay '", other[[2]], "' of provided Seurat object, please supply valid input!")
            }
          }
        } else {
          for (i in 1:length(input)) {
            if ("Assay5" %in% methods::is(other[[1]][[other[[2]][i]]])) {
              if (!(paste0(input[i], other[[4]][1]) %in% names(other[[1]][[other[[2]][i]]]@layers))) {
                stop("Layer '", paste0(input[i], other[[4]][1]), "' is not present in assay '", other[[2]][i], "' of provided Seurat v5 object, please supply valid input!")
              }
              if (!(paste0(input[i], other[[4]][2]) %in% names(other[[1]][[other[[2]][i]]]@layers))) {
                stop("Layer '", paste0(input[i], other[[4]][2]), "' is not present in assay '", other[[2]][i], "' of provided Seurat v5 object, please supply valid input!")
              }
            } else {
              try(slot_exists <- methods::validObject(methods::slot(other[[1]][[other[[2]][i]]], paste0(input[i], other[[4]][1]))))
              if (!exists("slot_exists")) {
                stop("Slot '", paste0(input[i], other[[4]][1]), "' is not present in assay '", other[[2]][i], "' of provided Seurat object, please supply valid input!")
              } else if (slot_exists == FALSE) {
                stop("Slot '", paste0(input[i], other[[4]][1]), "' is not present in assay '", other[[2]][i], "' of provided Seurat object, please supply valid input!")
                rm(slot_exists)
              } else {
                rm(slot_exists)
              }
              try(slot_exists <- methods::validObject(methods::slot(other[[1]][[other[[2]][i]]], paste0(input[i], other[[4]][2]))))
              if (!exists("slot_exists")) {
                stop("Slot '", paste0(input[i], other[[4]][2]), "' is not present in assay '", other[[2]][i], "' of provided Seurat object, please supply valid input!")
              } else if (slot_exists == FALSE) {
                stop("Slot '", paste0(input[i], other[[4]][2]), "' is not present in assay '", other[[2]][i], "' of provided Seurat object, please supply valid input!")
                rm(slot_exists)
              } else {
                rm(slot_exists)
              }
            }
          }
        }
      } else {
        warning("Input value(s) for '", name, "' are not used when provided object is not of class 'Seurat'.")
      }
    }
  }

  # ArchR_matrix
  if (name == "ArchR_matrix") {
    # if not NULL
    if (!is.null(input)) {
      # Only relevant for ArchR objects
      if (methods::is(other[[1]], "ArchRProject")) {
        # Should be of class 'character'
        if (!methods::is(input, "character")) {
          stop("Input value for '", name, "' is not of class 'character', please supply valid input!")
        }
        # Each value must exist in provided object
        available_matrices <- ArchR::getAvailableMatrices(other[[1]])
        # Dependent on countsplitting
        if (other[[2]] == TRUE) {
          # Default countsplit_suffix values if NULL
          if (is.null(other[[3]])) {
            other[[3]] <- c("_1", "_2")
          }
          input_to_check <- c(paste0(input, other[[3]][1]), paste0(input, other[[3]][2]))
        } else {
          input_to_check <- input
        }
        for (i in 1:length(input_to_check)) {
          if (!(input_to_check[i] %in% available_matrices)) {
            stop("Matrix '", input_to_check[i], "' is not present in provided object, please supply valid input!")
          }
        }
      } else {
        warning("Input value(s) for '", name, "' are not used when provided object is not of class 'ArchRProject'.")
      }
    }
  }

  # ArchR_depthcol
  if (name == "ArchR_depthcol") {
    # if not NULL
    if (!is.null(input)) {
      # Only relevant for ArchR objects
      if (methods::is(other[[1]], "ArchRProject")) {
        # Should be of class 'character'
        if (!methods::is(input, "character")) {
          stop("Input value for '", name, "' is not of class 'character', please supply valid input!")
        }
        # Length must be either 1 or same as n_modalities
        if (length(input) != 1 & length(input) != other[[2]]) {
          stop("Input value(s) for '", name, "' must be either length 1 or same length as the number of modalities provided for 'ArchR_matrix'.")
        }
        # Must exist in object
        for (i in 1:length(input)) {
          if (!(input[i] %in% colnames(other[[1]]@cellColData))) {
            stop("Column '", input[i], "' supplied for '", name, "' is not present in 'cellColData' of the provided object, please supply valid input!")
          }
        }
      } else {
        warning("Input value(s) for '", name, "' are not used when provided object is not of class 'ArchRProject'.")
      }
    }
  }

  # reduction
  if (name == "reduction") {
    # If not NULL
    if (!is.null(input)) {
      if (other[[1]] %in% c("plotCHOIR", "runCHOIRumap")) {
        # Should be of class 'character'
        if (!methods::is(input, "character")) {
          stop("Input value for '", name, "' is not of class 'character', please supply valid input!")
        }
        # Check if reduction exists in object
        if (methods::is(other[[2]], "Seurat")) {
          reduction_names <- names(other[[2]]@misc[[other[[3]]]][["reduction"]])
        } else if (methods::is(other[[2]], "SingleCellExperiment")) {
          reduction_names <- names(other[[2]]@metadata[[other[[3]]]][["reduction"]])
        } else if (methods::is(other[[2]], "ArchRProject")) {
          reduction_names <- names(other[[2]]@projectMetadata[[other[[3]]]][["reduction"]])
        }
        if (!(input %in% reduction_names)) {
          stop("Input value '", input, "' for '", name,
               "' was not found in the provided object, please supply valid input!")
        }
      } else if (other[[1]] == "inferTree") {
        # Should be of class "matrix"
        if (!methods::is(input, "matrix")) {
          stop("Input value for '", name, "' is not of class 'matrix', please supply valid input!")
        }
        # Must have at least 2 columns
        if (ncol(input) < 2) {
          stop("Input value for '", name, "' must have at least 2 columns, please supply valid input!")
        }
        # Row names must be cell IDs
        if (!identical(rownames(input), other[[2]])) {
          stop("Row names for input to '", name, "' must correspond to cell IDs, please supply valid input!")
        }
      } else {
        # Should be of class "matrix"
        if (!methods::is(input, "matrix")) {
          stop("Input value for '", name, "' is not of class 'matrix', please supply valid input!")
        }
        # Must have at least 2 columns
        if (ncol(input) < 2) {
          stop("Input value for '", name, "' must have at least 2 columns, please supply valid input!")
        }
      }
    }
  }

  # var_features
  if (name == "var_features") {
    # If NULL
    if (is.null(input)) {
      # Reduction must also be NULL
      if (!is.null(other)) {
        stop("If 'reduction' is supplied by user, '", name, "' cannot be NULL and must also be supplied.")
      }
    } else {
      # Reduction must also be not NULL
      if (is.null(other)) {
        stop("If '", name, "' is supplied by user, 'reduction' cannot be NULL and must also be supplied.")
      }
      # Should be of class 'character'
      if (!methods::is(input, "character")) {
        stop("Input value for '", name, "' is not of class 'character', please supply valid input!")
      }
      # Warn if length < 100
      if (length(input) < 100) {
        warning("The provided input to '", name, "' has length ", length(input), ". A greater number of variable features is recommended.")
      }
    }
  }

  # atac
  if (name == "atac") {
    # Must be T/F
    if (!methods::is(input, "logical")) {
      stop("Input value for '", name, "' is not of class 'logical', please supply valid input!")
    }
    # Length must be either 1 or same as n_modalities
    if (length(input) != 1 & length(input) != other) {
      stop("Input value(s) for '", name, "' must be either length 1 or same length as the number of modalities provided for 'use_assay' or 'ArchR_matrix'.")
    }
  }

  # n_cores
  if (name == "n_cores") {
    # If not NULL
    if (!is.null(input)) {
      # Should be of class 'numeric'
      if (!methods::is(input, "numeric")) {
        stop("Input value for '", name, "' is not of class 'numeric', please supply valid input!")
      }
      # Must be a single positive integer
      if (input %% 1 != 0 | input < 1 | length(input) != 1) {
        stop("Input value for '", name, "' must be a single positive integer, please supply valid input!")
      }
      # Doesn't exceed the number of available cores
      if (input > parallel::detectCores()) {
        stop("Input value for '", name, "' exceeds the number of available cores, please supply valid input!")
      }
    }
  }

  # Single logical value
  # verbose, collect_all_metrics, use_variance, legend, accuracy_scores, countsplit
  if (name %in% c("verbose", "collect_all_metrics", "use_variance", "legend", "accuracy_scores", "countsplit")) {
    # Must be T/F
    if (!methods::is(input, "logical") | length(input) != 1) {
      stop("Input value for '", name, "' is not a single value of class 'logical', please supply valid input!")
    }
  }

  # cluster1_cells, cluster2_cells
  if (name %in% c("cluster1_cells", "cluster2_cells")) {
    # If not NULL
    if (!is.null(input)) {
      # Should be of class 'character'
      if (!methods::is(input, "character")) {
        stop("Input value for '", name, "' is not of class 'character', please supply valid input!")
      }
      # The other cells must not be NULL
      if (is.null(other)) {
        if (name == "cluster1_cells") {
          stop("When input values for 'cluster1_cells' are provided, input for 'cluster2_cells' cannot be NULL. Please supply valid input!")
        } else {
          stop("When input values for 'cluster2_cells' are provided, input for 'cluster1_cells' cannot be NULL. Please supply valid input!")
        }
      }
      # Must not overlap with the other cluster cells
      if (length(intersect(input, other)) > 1) {
        stop("Input values for 'cluster1_cells' and 'cluster2_cells' must not overlap. Please supply valid input!")
      }
    }
  }

  # input_matrix
  if (name == "input_matrix") {
    # If not NULL
    if (!is.null(input)) {
      # Should be of permitted matrix class
      if (!(any(methods::is(input) %in% c("mMatrix", "matrix", "dgCMatrix", "IterableMatrix", "Matrix")))) {
        stop("Input value for '", name, "' is not among permitted classes: 'mMatrix', 'matrix', 'dgCMatrix', 'IterableMatrix', 'Matrix', please supply valid input!")
      }
      # Must have at least 1 row
      if (nrow(input) < 1) {
        stop("Input value for '", name, "' must have at least 1 row, please supply valid input!")
      }
      # Column names must contain all cell IDs
      if (!all(other %in% colnames(input))) {
        stop("Input value for '", name, "' must be a feature x cell matrix in which the column names contain all of the cell IDs provided or present in the object.")
      }
    }
  }

  # nn_matrix or snn_matrix
  if (name %in% c("nn_matrix", "snn_matrix")) {
    # If not NULL
    if (!is.null(input)) {
      # Should be of permitted matrix class
      if (!(any(methods::is(input) %in% c("mMatrix", "matrix", "dgCMatrix", "IterableMatrix", "Matrix")))) {
        stop("Input value for '", name, "' is not among permitted classes: 'mMatrix', 'matrix', 'dgCMatrix', 'IterableMatrix', 'Matrix', please supply valid input!")
      }
      # Row and column names must contain all cell IDs
      if (!all(other %in% colnames(input)) | !all(other %in% rownames(input))) {
        stop("Input value for '", name, "' must be an adjacency matrix in which the row and column names contain all of the cell IDs provided or present in the object.")
      }
    }
  }

  # dist_matrix
  if (name == "dist_matrix") {
    # If not NULL
    if (!is.null(input)) {
      # Should be of class "mMatrix" or "matrix
      if (!methods::is(input, "mMatrix") & !methods::is(input, "matrix")) {
        stop("Input value for '", name, "' is not of class 'mMatrix' or 'matrix', please supply valid input!")
      }
      # Row and column names must contain all cell IDs
      if (!all(other %in% colnames(input)) | !all(other %in% rownames(input))) {
        stop("Input value for '", name, "' must be a distance matrix in which the row and column names contain all of the cell IDs provided or present in the object.")
      }
    }
  }

  # p_adjust
  if (name == "p_adjust") {
    # Should be a single value of class "character"
    if (!methods::is(input, "character") | length(input) != 1) {
      stop("Input value for '", name, "' must be a single value of class 'character', please supply valid input!")
    }
    # Must be among permitted values
    if (!(input %in% c("fdr", "bonferroni", "none"))) {
      stop("Input value ", input, " for '", name, "' is not among the permitted values: 'fdr', 'bonferroni', and 'none'. Please supply valid input!")
    }
  }

  # distance_awareness
  if (name == "distance_awareness") {
    # Should be a single value of class "numeric" or "logical"
    if (methods::is(input, "numeric") && length(input) == 1) {
      # Must be 1 or above
      if (input < 1) {
        stop("Input value for '", name, "' must be 1 or above, please supply valid input!")
      }
      # Warning if under 1.25
      if (input < 1.25) {
        warning("Input value for '", name, "' is under 1.25, consider increasing this value to account for the inherent inexactness of distance measurements.")
      }
    } else if (methods::is(input, "logical") && length(input) == 1) {
      # Must be 'FALSE'
      if (input != FALSE) {
        stop("Input value for '", name, "' must be single value of class 'numeric' or set to FALSE, please supply valid input!")
      }
    } else {
      stop("Input value for '", name, "' must be single value of class 'numeric' or set to FALSE, please supply valid input!")
    }
  }

  # cluster_tree
  if (name == "cluster_tree") {
    # If not NULL
    if (!is.null(input)) {
      # Must be a matrix or dataframe
      if (!methods::is(input, "matrix") & !methods::is(input, "data.frame")) {
        stop("Input value for 'cluster_tree' is not of class 'matrix' or 'data.frame', please supply valid input!")
      }
      # Must have at least 2 columns
      if (ncol(input) < 2) {
        stop("Input value for 'cluster_tree' must have at least 2 columns, please supply valid input!")
      }
      # Number of rows must equal number of cells in object
      if (methods::is(other, "Seurat") | methods::is(other, "SingleCellExperiment")) {
        n_cells <- ncol(other)
        cell_ids <- colnames(other)
      } else if (methods::is(other, "ArchRProject")) {
        n_cells <- nrow(other@cellColData)
        cell_ids <- rownames(other@cellColData)
      }
      if (nrow(input) != n_cells) {
        stop("Input value for 'cluster_tree' must be a dataframe or matrix in which the number of rows is equal to the number of cells in the provided object. Please supply valid input or set to NULL.")
      }
      # Row names must match cell names
      if (!(identical(cell_ids, rownames(input)))) {
        stop("Input value for 'cluster_tree' must be a dataframe or matrix in which the row names and order are identical to the cell IDs in the provided object. Please supply valid input or set to NULL.")
      }
    }
  }

  # distance_approx
  if (name == "distance_approx") {
    # Must be T/F
    if (!methods::is(input, "logical") | length(input) != 1) {
      stop("Input value for '", name, "' is not a single value of class 'logical', please supply valid input!")
    }
    # If TRUE and object is of type Seurat or SingleCellExperiment with more than 1 modality, stop
    if (input == TRUE &
        ("Seurat" %in% methods::is(other[[2]]) | "SingleCellExperiment" %in% methods::is(other[[2]])) &
        other[[3]] > 1) {
      stop("Distance approximation is incompatible with multi-modal data of class 'Seurat' or 'SingleCellExperiment'. Please provide an object of class 'ArchRProject', set '", name, "' to 'FALSE', or use a single modality.")
    } else if (input == FALSE & other[[1]] >= 500) { # If FALSE and number of cells is higher than 500, issue warning
      warning("Setting parameter '", name, "' to ", input, " may slow down computation.")
    }
  }

  # feature_set
  if (name == "feature_set") {
    # Should be a single value of class "character"
    if (!methods::is(input, "character") | length(input) != 1) {
      stop("Input value for '", name, "' must be a single value of class 'character', please supply valid input!")
    }
    # Must be among permitted values
    if (!(input %in% c("var", "all"))) {
      stop("Input value ", input, " for '", name, "' is not among the permitted values: 'var' and 'all'. Please supply valid input!")
    }
    # If normalization method is "SCT", stop if feature_set is "all"
    if (other[[1]] %in% c("buildTree", "pruneTree", "combineTrees")) {
      if (other[[2]] == "SCTransform" & input == "all") {
        stop("'SCTransform' normalization cannot be used when parameter '", name, "' is 'all', please set '", name,
             "' to 'var' or provide normalized data.")
      }
      # If object contains ATAC data, warn if feature_set is "all"
      if (other[[1]] == "buildTree") {
        if (any(other[[3]]) & input == "all") {
          warning("It is not recommended to set parameter '", name, "' is 'all' when using ATAC-seq data.")
        }
      }
    }
  }

  # sample_max
  if (name == "sample_max") {
    # Should be of class 'numeric', must be a single value
    if (!methods::is(input, "numeric") | length(input) != 1) {
      stop("Input value for '", name, "' must be a single value of class 'numeric'. Please supply valid input!")
    }
    # Must be positive
    if (input != Inf) {
      if (input < 1 | input %% 1 != 0)
      stop("Input value for '", name, "' must be either Inf or a positive integer. Please supply valid input!")
    }
  }

  # downsampling_rate
  if (name == "downsampling_rate") {
    if (input != "auto") {
      # Should be of class 'numeric', must be a single value
      if (!methods::is(input, "numeric") | length(input) != 1) {
        stop("Input value for '", name, "' must be either NULL or a single value of class 'numeric'. Please supply valid input!")
      }
      # Must be above 0
      if (input <= 0) {
        stop("Input value for '", name, "' must be either NULL or a positive number. Please supply valid input!")
      }
    }
  }

  # min_reads
  if (name == "min_reads") {
    if (!is.null(input)) {
      # Should be of class 'numeric', must be a single value
      if (!methods::is(input, "numeric") | length(input) != 1) {
        stop("Input value for '", name, "' must be either NULL or a single value of class 'numeric'. Please supply valid input!")
      }
      # Must be above 0
      if (input <= 0) {
        stop("Input value for '", name, "' must be either NULL or a positive number. Please supply valid input!")
      }
    }
  }

  # min_cluster_depth
  if (name == "cluster_depth") {
    # Should be of class 'numeric', must be a single value
    if (!methods::is(input, "numeric") | length(input) != 1) {
      stop("Input value for '", name, "' must be a single value of class 'numeric'. Please supply valid input!")
    }
    # Must be Inf or a positive integer
    if (input %% 1 != 0 | input < 1) {
        stop("Input value for '", name, "' must be Inf or a positive integer. Please supply valid input!")
      }
    # Warn if too high
    if (input > 5000) {
      warning("High input values for '", name, "' may slow down computation.")
    }
  }

  # cells
  if (name == "cells") {
    if (methods::is(other, "Seurat") | methods::is(other, "SingleCellExperiment")) {
      cell_ids <- colnames(other)
    } else if (methods::is(other, "ArchRProject")) {
      cell_ids <- rownames(other@cellColData)
    }
    if (length(intersect(input, cell_ids)) != length(input)) {
      stop("Not all provided cells are present in the provided object, please supply valid input!")
    }
  }

  # ident1
  if (name %in% c("ident1", "ident2")) {
    # If not NULL
    if (!is.null(input)) {
      # Other ident cannot be NULL
      if (is.null(other[[3]])) {
        if (name == "ident1") {
          stop("When input value for 'ident1' is provided, input for 'ident2' cannot be NULL. Please supply valid input!")
        } else {
          stop("When input value for 'ident2' is provided, input for 'ident1' cannot be NULL. Please supply valid input!")
        }
      }
      # Must not be equal to opposing ident
      if (input == other[[3]]) {
        stop("Input values for 'ident1' and 'ident2' must not be the same, please supply valid input!")
      }
      # Must be present in 'group_by' column of metadata of provided object
      if (methods::is(other[[1]], "Seurat")) {
        if (!(input %in% unique(other[[1]]@meta.data[, other[[2]]]))) {
          stop("Input value for '", name, "' must exist in the column", other[[2]], " in the 'meta.data' of the provided object, please supply valid input!")
        }
      } else if (methods::is(other[[1]], "SingleCellExperiment")) {
        if (!(input %in% unique(other[[1]]@colData[, other[[2]]]))) {
          stop("Input value for '", name, "' must exist in the column", other[[2]], " in the 'colData' of the provided object, please supply valid input!")
        }
      } else if (methods::is(other[[1]], "ArchRProject")) {
        if (!(input %in% unique(other[[1]]@cellColData[, other[[2]]]))) {
          stop("Input value for '", name, "' must exist in the column", other[[2]], " in the 'cellColData' of the provided object, please supply valid input!")
        }
      }
    }
  }

  # cluster_labels
  if (name == "cluster_labels") {
    # Should be named vector of length >1.
    if (length(input) <= 1) {
      stop("Input value for '", name, "' must be a vector with at least 2 values, please supply valid input!")
    }
    # Must be named
    if (is.null(names(input))) {
      stop("Input value ", input, " for '", name, "' must be named according to the cell IDs corresponding to each cluster label. Please supply valid input!")
    }
  }

  # countsplit_suffix
  if (name == "countsplit_suffix") {
    # If not NULL
    if (!is.null(input)) {
      # Should be of class 'character', must be a vector with exactly 2 values
      if (!methods::is(input, "character") | length(input) != 2) {
        stop("Input for '", name, "' must be a vector of class 'character' with exactly 2 values. Please supply valid input!")
      }
      # Warn if 'countsplit' is FALSE
      if (other == FALSE) {
        warning("Input for '", name, "' is not used when parameter 'countsplit' is set to FALSE.")
      }
    }
  }

  # countsplit_params
  if (name == "countsplit_params") {
    # Check that it is a list
    if (!methods::is(input, "list")) {
      stop("Input value for '", name, "' is not of class 'list', please supply valid input!")
    }
  }

  # subtree_list
  if (name == "subtree_list") {
    # Check that it is a list
    if (!methods::is(input, "list")) {
      stop("Input value for '", name, "' is not of class 'list', please supply valid input!")
    }
    # Check minimum required content
    for (s in 1:length(input)) {
      if (!("clusters" %in% names(input[[s]]))) {
        stop("Index ", s, "in provided value for '", name, "' does not contain required data under name 'clusters', please supply valid input!")
      }
    }
  }
}
